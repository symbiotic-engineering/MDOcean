%[AUTOGENERATED]
function [treeFig, parallelFig, barFig, results] = multistart_postpro(p,b,X_opt,objs,flags,x0s,num_runs)
% Function multistart_postpro
%
% :param p: Parameter struct
% :param b: Design variable bounds struct
% :param X_opt: Optimal design variables
% :param objs: objs
% :param flags: Optimization output flags
% :param x0s: x0s
% :param num_runs: num_runs
% :returns: treeFig
% :returns: parallelFig
% :returns: barFig
% :returns: results

    %% create table for display
    results = struct2table(x0s);
    cents_per_dollar = 100;
    obj_names_star = {[b.obj_names{1} '*'],[b.obj_names{2} '*']};
    obj_names_star_norm = strcat(obj_names_star, '_norm');
    J_nom = simulation([b.X_noms; 1],p);
    scale = repmat([cents_per_dollar 1],num_runs,1); % scale LCOE units for display
    results = addvars(results, objs(:,1).*scale(:,1), objs(:,2).*scale(:,2), ...
                      objs(:,1)/J_nom(1), objs(:,2)/J_nom(2), flags,  ...
        'NewVariableNames', [obj_names_star,obj_names_star_norm,'Flag']);

    for i=1:length(b.var_names)-1
        X = X_opt(:,i,:);
        results = addvars(results, results.(b.var_names{i})./b.X_noms(i),...
                          X(:,1), X(:,1)./b.X_noms(i), ...
                          X(:,2), X(:,2)./b.X_noms(i),...
                          'NewVariableNames', ...
                        {[b.var_names{i} '_norm'],...
                         [b.var_names{i} '_opt_' b.obj_names{1}],...
                         [b.var_names{i} '_opt_' b.obj_names{1} '_norm'],...
                         [b.var_names{i} '_opt_' b.obj_names{2}],...
                         [b.var_names{i} '_opt_' b.obj_names{2} '_norm'],...
                         }, 'After', b.var_names{i});
    end


    %% summary statistics
    lin_feasible = isfinite(objs);
    conv = flags > 0 & lin_feasible; % converged
    kkt = flags == 1;
    tol = 0.001;
    opt = abs(objs - min(objs)) < tol; % this assumes that solutions converging
    % to the same objective value have the same optimal DVs, which is not guaranteed
    % but seems correct in this case by inspection of the table above

    % optimal_and_converged = conv & opt;
    % optimal_and_kkt = kkt & opt;
    %
    % percent_lin_feas = sum(lin_feasible) / num_runs
    % percent_converged_given_lin_feas = sum(conv) / sum(lin_feasible)
    % percent_kkt_given_lin_feas = sum(kkt) / sum(lin_feasible)
    %
    % percent_optimal_given_lin_feas = sum(opt) / num_runs
    % percent_optimal_given_converged = sum(optimal_and_converged) ./ sum(conv)
    % percent_optimal_given_kkt = sum(optimal_and_kkt) ./ sum(kkt)

    %% add column for global min
    global_min_cat = categorical(sum(opt,2),[0 1 2],{'Neither Objective','One Objective','Both Objectives'},'Ordinal',true);
    results = addvars(results,global_min_cat,'NewVariableNames','Global Min');


    %% table visualization
    results = sortrows(results,['Global Min','Flag',obj_names_star],'descend');

    %results_display = results;
    %results_display.Variables =  round(results_display.Variables,1);
    %disp(results_display)

    %% tree plot
    edge_connections = [2 1;
                        3 1;
                        4 2;
                        5 2;
                        6 2;
                        7 4;
                        8 4;
                        9 5;
                        10 5;
                        11 6;
                        12 6];
    node_names = {[num2str(num_runs) ' random points'],...
        'linear feasible','linear infeasible',...
        'KKT','Converged, not KKT','Not converged',...
        'Global Min','Local Min','Global Min ','Local Min ','Global Min  ','Local Min  '};

    edge_weights = [           sum(lin_feasible);                                                                               sum(~lin_feasible); ...
                    sum(kkt);                      sum(conv & ~kkt);                      sum(~conv & lin_feasible);...
      sum(opt&kkt); sum(~opt&kkt);  sum(conv & ~kkt & opt); sum(conv & ~kkt & ~opt);  sum(~conv & opt); sum(~conv & ~opt & lin_feasible)];


    G_J1 = digraph(edge_connections(:,2),edge_connections(:,1),edge_weights(:,1),node_names);
    G_J2 = digraph(edge_connections(:,2),edge_connections(:,1),edge_weights(:,2),node_names);
    treeFig = figure;
    t = tiledlayout(1, 2);
    %t.TileSpacing = 'tight';
    t.Padding = 'compact';
    nexttile
    plot(G_J1,'NodeLabel',G_J1.Nodes.Name,'EdgeLabel',G_J1.Edges.Weight,...
        'NodeFontSize',10,'EdgeFontSize',12,'MarkerSize',8,'LineWidth',1)
    title('LCOE minimization')
    axis off
    nexttile
    plot(G_J2,'NodeLabel',G_J2.Nodes.Name,'EdgeLabel',G_J2.Edges.Weight,...
        'NodeFontSize',10,'EdgeFontSize',12,'MarkerSize',8,'LineWidth',1)
    title('Design Cost Minimization')
    axis off
    improvePlot

    %% parallel axis plot
    parallelFig = figure(Units="normalized", Position=[0.1,0.2,0.3,0.4], Color="white");
    t = tiledlayout(3, 4);
    t.TileSpacing = 'compact';
    t.Padding = 'compact';

    % handle cases when not all categories appear
    idx_used = double(unique(global_min_cat));
    orange = '#EDB120';
    cols = {'g',orange,'r'};
    cols_used = cols(idx_used);
    lines = {'-','-.','--'};
    lines_used = lines(idx_used);
    widths = [2,2,1];
    widths_used = widths(idx_used);

    fontsize = 12;
    num_DVs = length(b.var_names);
    for i=1:num_DVs-1
        nexttile
        table_var_names = results.Properties.VariableNames;
        dv_idx = contains(table_var_names,[b.var_names{i} '_']) & contains(table_var_names,'_norm'); % the extra underscore is to avoid h_s picking up h_stiff_f
        vars = [table_var_names(dv_idx) obj_names_star_norm];
    %     if i==9
    %         leg='on';
    %     else
    %         leg='off';
    %     end
        idx_finite = isfinite( results.(obj_names_star{1}) );
        results_finite = results(idx_finite,:);
        h = parallelplot(results_finite,'CoordinateVariables',vars,...
                                 'DataNormalization','none',...
                                 'GroupVariable','Global Min',...
                                 'Color',cols_used, ...
                                 'LineStyle',lines_used,...
                                 'LineWidth',widths_used,...
                                 'LegendVisible','off',...
                                 'Jitter',0,...
                                 'FontSize',fontsize,...
                                 'Title',[b.var_descs{i} ' ' b.var_names_pretty{i}]);
        h.CoordinateTickLabels = ""; % Suppress x tick labels in original axes

        if i>8
            labels = { '$$\frac{x_0}{x_{nom}}$$',...
                     ['$$\frac{x^*(' b.obj_names_pretty{1} '^*)}{x_{nom}}$$'],...
                     ['$$\frac{x^*(' b.obj_names_pretty{2} '^*)}{x_{nom}}$$'],...
                     ['$$\frac{' b.obj_names_pretty{1} '^*}{' b.obj_names_pretty{1} '_{nom}}$$'],...
                     ['$$\frac{' b.obj_names_pretty{2} '^*}{' b.obj_names_pretty{2} ',nom}$$'] };

            nLabels = numel(labels);
            hAxesOverlay= axes(t);
            hAxesOverlay.Layout.Tile=i;
            if i==9
                for j=1:length(cols_used)
                    plot(hAxesOverlay,NaN,NaN,lines_used{j},'LineWidth',1.5,'Color',cols_used{j})
                    hold on
                end
                leg = legend(hAxesOverlay,flipud(unique(global_min_cat)),'FontSize',fontsize);
                leg.Layout.Tile = 'east';
                title(leg,'Global Min','FontSize',fontsize)
                set(hAxesOverlay,Box='off');
            end
            set(hAxesOverlay, XLim=[0.5,nLabels+0.5], ...
                Color="none", XColor="black", YColor="none", ...
                XTick=1:nLabels, XTickLabels=labels,...
                TickLabelInterpreter='latex',...
                FontSize=fontsize-2);

        end
    end

    %% bar plot data

    for i=1:length(b.var_names)-1
        % capital X is design vars, lowercase x is indep var in sensitivity
        % analysis, y is dependent variable in sensitivity analysis
        X_guess = results.(b.var_names{i});
        X_optim_result = squeeze(X_opt(:,i,:));
        X_global_opt = X_optim_result(opt);

        x_J1(:,i) = X_guess ./ X_global_opt(1) - 1;
        x_J2(:,i) = X_guess ./ X_global_opt(2) - 1;

        y_J1_X(:,i) = X_optim_result(:,1) ./ X_global_opt(1) - 1;
        y_J2_X(:,i) = X_optim_result(:,2) ./ X_global_opt(2) - 1;
    end

    J_global_opt = objs(opt);
    y_J1_J = objs(:,1)/J_global_opt(1) - 1;
    y_J2_J = objs(:,2)/J_global_opt(2) - 1;

    %% PAWN sensitivity metric
    for i=1:length(b.var_names)-1
        [~, S_J1_X_all(i), S_J1_X_self(i)] = call_pawn(x_J1, y_J1_X(:,i), i);
        [~, S_J2_X_all(i), S_J2_X_self(i)] = call_pawn(x_J1, y_J1_X(:,i), i);
    end

    S_J1_J = call_pawn(x_J1, y_J1_J);
    S_J2_J = call_pawn(x_J2, y_J2_J);

    if ~iscolumn(S_J1_X_all) % ensure all column vectors
        S_J1_X_self = S_J1_X_self.';
        S_J1_J = S_J1_J.';
        S_J2_X_self = S_J2_X_self.';
        S_J2_J = S_J2_J.';
    end

    %% bar plot
    barFig = figure;
    bar_data = [S_J1_X_self, S_J1_J, S_J2_X_self, S_J2_J];
    bar_data_clean = fillmissing(bar_data,'constant',0);
    bar(categorical(b.var_names_pretty(1:end-1)),bar_data_clean)
    title('Sensitivity to starting point');
    legend({['X* Sensitivity for J_1 = ' b.obj_names_pretty{1}], ...
            ['J* Sensitivity for J_1 = ' b.obj_names_pretty{1}], ...
            ['X* Sensitivity for J_2 = ' b.obj_names_pretty{2}], ...
            ['J* Sensitivity for J_2 = ' b.obj_names_pretty{2}], ...
        })
    improvePlot
end

function [sens_vec,sens_mean,sens_self] = call_pawn(x,y,idx_self)
    n = 10; % Pianosi and Wagener 2015 says use n=10-50
    nboot = 1; % Pianosi and Wagener 2015 use nboot=200-1000

    sens_vec = pawn_indices_givendata(x(~isnan(y),:), y(~isnan(y)), n, nboot); % sens to each var
    sens_mean = mean(sens_vec,'omitnan'); % sens to all vars start point
    if nargout > 2
        sens_self = sens_vec(idx_self);   % sens to self start point
    end

end
