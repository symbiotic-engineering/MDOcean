%[AUTOGENERATED]
%[AUTOGENERATED]
function figs = make_four_loads_plot(theta,rho,result,idx_max,title_string, take_abs)
% Function make_four_loads_plot
%
% :param theta: $\\theta$
% :param rho: Density of seawater (kg/m^3)
% :param result: result
% :param idx_max: idx_max
% :param title_string: title_string
% :param take_abs: take_abs
% :returns: Figure handles
% creates 3 figures for damping plate: 
% 1. line plot of result vs theta for various rho, for single load
% 2. line plot of result vs theta at rho=rho(idx_max), for 4 equally-spaced superimposed loads
% 3. geometrically accurate polar contour plot of result vs rho/theta, for
%    4 equally-spaced superimposed loads.
% Theta must be in radians. This function assumes even radial symmetry: 
% result(-theta) = result(theta), so you would typically pass theta = 0 to pi.
% Result is any relevant quantity that has been evaluated for a
% single load on the theta/rho mesh.

    theta_full = [fliplr(-theta) theta];
    result_full = [fliplr(result) result];

    if take_abs
        result_full_plot = abs(result_full);
    else
        result_full_plot = result_full;
    end

    f1 = figure;
    plot(180/pi*theta_full, result_full_plot)
    xlabel('\theta (degrees)')
    ylabel(title_string)
    title([title_string ' for various radii, single load'])
    
    [theta_0,result_0] = shift(theta_full,result_full,0);
    [theta_90,result_90] = shift(theta_full,result_full,pi/2);
    [theta_180,result_180] = shift(theta_full,result_full,pi);
    [theta_270,result_270] = shift(theta_full,result_full,3*pi/2);
    
   
    result_0_max   = result_0(idx_max,:); 
    result_90_max  = result_90(idx_max,:); 
    result_180_max = result_180(idx_max,:); 
    result_270_max = result_270(idx_max,:); 
    
    result_max_total = result_0_max + result_90_max + result_180_max + result_270_max;

    if take_abs % abs each one AFTER taking the sum, to allow positives and negatives to cancel in sum
        result_0_max = abs(result_0_max);
        result_90_max = abs(result_90_max);
        result_180_max = abs(result_180_max);
        result_270_max = abs(result_270_max);
        result_max_total = abs(result_max_total);
    end

    f2 = figure;
    plot(180/pi*theta_0,result_0_max)
    hold on
    plot(180/pi*theta_90,result_90_max)
    plot(180/pi*theta_180,result_180_max)
    plot(180/pi*theta_270,result_270_max)
    plot(180/pi*theta_0, result_max_total,'--')
    xlabel('\theta (degrees)')
    ylabel(title_string)
    title(['Maximum ' title_string ', four corner loads'])
    
    f3 = figure;
    x = rho'*cos(theta_0);
    y = rho'*sin(theta_0);
    z = result_0 + result_90 + result_180 + result_270;
    if take_abs
        z = abs(z);
    end
    contourf(x,y,z)
    colorbar
    axis equal
    title([title_string ', four corner loads'])

    figs = [f1 f2 f3];
end

function [theta_shift,x_shift] = shift(theta, x, delta_theta)
% fixme: if I wanted to make a contour plot of deflection or Mr over a
% theta/rho mesh, I need to fix this function to accept matrix inputs for x
    theta_shift = wrapToPi(theta + delta_theta);
    [theta_shift,sort_idx] = sort(theta_shift);
    [theta_shift,unique_idx] = unique(theta_shift);
    sort_idx = sort_idx(unique_idx);
    x_shift = x(:,sort_idx);

    % add start point that equals end point
    if theta_shift(1)+2*pi ~= theta_shift(end)
        theta_shift = [theta_shift(end)-2*pi theta_shift];
        x_shift = [x_shift(:,end) x_shift];
    end
end