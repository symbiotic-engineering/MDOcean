%[AUTOGENERATED]
function [X_opt,objs,flags,x0s,num_runs] = gradient_mult_x0(p,b)
% Function gradient_mult_x0
%
% :param p: Parameter struct
% :param b: Design variable bounds struct
% :returns: Optimal design variables
% :returns: objs
% :returns: Optimization output flags
% :returns: x0s
% :returns: num_runs

    num_runs = 1000;
    num_DVs = length(b.var_names);
    num_objs = 2;
    objs = Inf(num_runs,num_objs);
    X_opt = NaN(num_runs,num_DVs,num_objs);
    flags = zeros(num_runs,num_objs);
    
    dry_run = false;

    % nominal ICs
    if ~dry_run
        [X_opt_nom, obj_opt_nom, flag_nom] = gradient_optim(b.X_start_struct,p,b);
    else
        X_opt_nom_1obj = [b.X_noms; 1];
        X_opt_nom = [X_opt_nom_1obj X_opt_nom_1obj];
        obj_opt_nom = simulation(X_opt_nom_1obj,p);
        obj_opt_nom = obj_opt_nom(1:num_objs);
        flag_nom = [1 1];
    end
    X_opt(1,:,:) = X_opt_nom;
    objs(1,:) = obj_opt_nom;
    flags(1,:) = flag_nom;
    x0s(1) = b.X_start_struct;
    
    % many random ICs
    parfor i = 2:num_runs
        [x0_vec,x0] = random_x0(b);
        [~, ~, ~, feasible_lin] = is_feasible(0, x0_vec, p, b);
        x0s(i) = x0;
        if feasible_lin
            if ~dry_run
                [X_opt(i,:,:), objs(i,:), flags(i,:)] = gradient_optim(x0,p,b);
            else
                X_opt(i,:,:) = rand() * [X_opt_nom X_opt_nom];
                objs(i,:) = rand() * obj_opt_nom;
                flags(i,:) = randi([-2,2],[1 2]);
            end
        end
    end

end
