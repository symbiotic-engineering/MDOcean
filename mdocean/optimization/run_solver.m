function [X_opt,obj_opt,flag,output,lambda,grad,hess,problem] = run_solver(prob, obj, x0, opts, idxs, filename_uuid)
    solver_based = true;
    % create folder for generated objectives if it doesn't already exist        
    if solver_based
        if isa(filename_uuid,'parallel.pool.Constant')
            filename_uuid = filename_uuid.Value;
        end
        generated_folder = ['optimization/generated/' filename_uuid];
        if ~exist(generated_folder,'dir')
            mkdir(generated_folder)
            addpath(generated_folder)
        end
        % Convert to solver-based
        problem = prob2struct(prob,x0,...
            'ObjectiveFunctionName',['generatedObjective' obj],...
            'FileLocation',generated_folder);
        problem.options = opts;
        
        if strcmp(opts.Algorithm,'sqp')
            problem.Aineq = full(problem.Aineq); % avoid warning that SQP can't have sparse matrices
        end
        
        % Run unscaled optimization
        [X_opt,obj_opt,flag,output,lambda,grad,hess] = fmincon(problem);
        
        if flag <= 0 % if the unscaled optimization did not arrive at an optimal
            % use the unscaled optimization hessian to find scale factor
            scale = 1./sqrt(diag(hess));

            % Formulate a new scaled optimization problem     
            problem_s = problem;
            problem_s.options.MaxIterations = 150;
            problem_s.options.MaxFunctionEvaluations = 2000;
            if ~isempty(problem.options.PlotFcn)
                problem_s.options.PlotFcn{2} = @(x,in1,in2) problem.options.PlotFcn{2}(x .* scale,in1,in2);  
            end
            problem_s.objective = @(x) problem.objective(x .* scale);  
            problem_s.nonlcon   = @(x) problem.nonlcon(x .* scale);
            problem_s.Aineq = problem.Aineq .* scale';

            inv_scale = 1./(scale);
            if ~isempty(output.bestfeasible)
                problem_s.x0 = inv_scale .* output.bestfeasible.x;
            else
                problem_s.x0 = inv_scale .* X_opt;
            end
            problem_s.lb = inv_scale .* problem.lb;
            problem_s.ub = inv_scale .* problem.ub;

            % Run scaled optimization problem
            [X_opt,obj_opt,flag,output,lambda,grad,hess] = fmincon(problem_s);
            X_opt = scale .* X_opt;
            lambda.lower = inv_scale .* lambda.lower;
            lambda.upper = inv_scale .* lambda.upper;
            grad = inv_scale .* grad;
            hess = (inv_scale * inv_scale.') .* hess;
        end
        
        % Rearrange outputs
        X_opt = X_opt(idxs); % reorder elements based on order in autogenerated objective files
        lambda.lower = lambda.lower(idxs);
        lambda.upper = lambda.upper(idxs);
        grad = grad(idxs);
        hess = hess(idxs,idxs);

    else
        [opt_x, obj_opt, flag,output,lambda] = solve(prob,x0,'Options',opts);
        X_opt = [opt_x.D_f opt_x.D_s_over_D_f opt_x.h_f_over_D_f ...
                opt_x.T_s_over_h_s opt_x.F_max ...
                opt_x.B_p opt_x.w_n opt_x.M opt_x.t_ft opt_x.t_fr opt_x.t_fc opt_x.t_fb opt_x.t_sr opt_x.t_dt opt_x.power_max];
    end
end